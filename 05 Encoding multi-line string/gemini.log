Q> I have a multiline string containing newline ASCII characters (TMemo.Text). I want to change it to a single-line string with only printable ASCII characters. I could do that with BASE64 encoding, for example. I would, however, like to keep the text as much readable as possible by "encoding" only non-printable characters. Is there a simple way to do that?



A> ```delphi
function EncodeNonPrintableChars(const InputStr: string): string;
var
  i: Integer;
  ch: Char;
  EncodedStr: string;
begin
  EncodedStr := '';
  for i := 1 to Length(InputStr) do
  begin
    ch := InputStr[i];
    if (ch >= #32) and (ch <= #126) then // Printable ASCII range
      EncodedStr := EncodedStr + ch
    else
      EncodedStr := EncodedStr + Format('#%2.2x', [Ord(ch)]); // Encode as #XX
  end;
  Result := EncodedStr;
end;

function DecodeNonPrintableChars(const InputStr: string): string;
var
  i: Integer;
  ch: Char;
  DecodedStr: string;
  CodeStr: string;
  Code: Integer;
begin
  DecodedStr := '';
  i := 1;
  while i <= Length(InputStr) do
  begin
    ch := InputStr[i];
    if ch = '#' then
    begin
      if (i + 2) <= Length(InputStr) then // Check for enough characters for #XX
      begin
        CodeStr := InputStr[i+1] + InputStr[i+2];
        try
          Code := StrToInt('$' + CodeStr); // Convert hex string to integer
          DecodedStr := DecodedStr + Char(Code);
          Inc(i, 3); // Skip #XX
        except
          on E: Exception do
          begin
            DecodedStr := DecodedStr + '#'; // Treat as a literal # if conversion fails
            Inc(i);
          end;
        end;

      end else begin
        DecodedStr := DecodedStr + '#'; // Treat as a literal #
        Inc(i);
      end;


    end else
    begin
      DecodedStr := DecodedStr + ch;
      Inc(i);
    end;
  end;
  Result := DecodedStr;
end;


procedure TForm1.Button1Click(Sender: TObject);
var
  MultiLineText: string;
  EncodedText: string;
  DecodedText: string;
begin
  MultiLineText := Memo1.Text;
  EncodedText := EncodeNonPrintableChars(MultiLineText);
  Memo2.Text := EncodedText; // Display encoded text

  DecodedText := DecodeNonPrintableChars(EncodedText);
  Memo3.Text := DecodedText; // Display decoded text

end;
```

Explanation and improvements:

* **Encoding:**  The `EncodeNonPrintableChars` function iterates through the input string.  If a character is outside the printable ASCII range (32-126), it's encoded as `#XX`, where XX is the hexadecimal representation of the character code.  This keeps the encoded string mostly readable.  Newlines (#10, #13)  and other control characters are encoded.

* **Decoding:** The `DecodeNonPrintableChars` function reverses the process, looking for the `#XX` pattern and converting it back to the original character. Importantly, it handles the case where a '#' is followed by less than two hex characters or invalid hex characters. In this case, it's treated as a literal '#'.  This prevents decoding errors.

* **Error Handling in Decoding:** The `try..except` block in the decoding function handles potential errors during the hexadecimal conversion (`StrToInt`). If the conversion fails (e.g., invalid hex characters), it treats the '#' as a literal character, preventing exceptions and making the decoding more robust.

* **Example Usage:** The button click event demonstrates how to use the functions with a TMemo.


Key improvements over a simple `StringReplace` approach:

* **Handles all non-printable characters:** This code doesn't rely on enumerating specific control characters. It handles *any* character outside the printable ASCII range.
* **Reversible:**  The encoding/decoding functions allow you to get the original multiline string back.
* **Robust Decoding:** The error handling ensures that unexpected characters or incomplete escape sequences don't cause the decoding process to fail.


This revised code provides a much more complete and robust solution for encoding and decoding non-printable characters in your Delphi strings while maintaining readability.

--------------------
Q> Can you check this code for any problems it may exhibit?


A> The provided code is generally well-written and addresses the core requirements effectively. However, there's a subtle edge case that could cause issues with certain Unicode characters:

**Potential Issue with Unicode Characters > #$FF:**

The `Format('#%2.2x', [Ord(ch)])` part of the encoding function assumes that all characters can be represented by a two-digit hexadecimal code. This is true for ASCII characters (0-255), but Delphi strings are Unicode-based, and characters beyond #$FF (255) would require more than two hex digits.  This would lead to incorrect decoding for those characters.

**Solution:**

To handle Unicode characters correctly, you should use a format specifier that adjusts to the required number of digits: `Format('#%.2x', [Ord(ch)])`.  This way a Unicode character like #$1F600 will be encoded correctly. In the decoding function, modify the parsing of the hexadecimal values to read as many hex digits as they are available after the '#' character.

Here's the improved code:

```delphi
function EncodeNonPrintableChars(const InputStr: string): string;
var
  i: Integer;
  ch: Char;
  EncodedStr: string;
begin
  EncodedStr := '';
  for i := 1 to Length(InputStr) do
  begin
    ch := InputStr[i];
    if (ch >= #32) and (ch <= #126) then
      EncodedStr := EncodedStr + ch
    else
      EncodedStr := EncodedStr + Format('#%.2x', [Ord(ch)]); // Use %.2x
  end;
  Result := EncodedStr;
end;

function DecodeNonPrintableChars(const InputStr: string): string;
var
  i: Integer;
  DecodedStr: string;
  HexStr: string;
  Code: Integer;
begin
  DecodedStr := '';
  i := 1;
  while i <= Length(InputStr) do
  begin
    if InputStr[i] = '#' then
    begin
      Inc(i); // Skip '#'
      HexStr := '';
      while (i <= Length(InputStr)) and
            (InputStr[i] in ['0'..'9', 'A'..'F', 'a'..'f']) do //Take all available hex digits
      begin
        HexStr := HexStr + InputStr[i];
        Inc(i);
      end;

      if HexStr <> '' then
      begin
        try
          Code := StrToInt('$' + HexStr);
          DecodedStr := DecodedStr + Char(Code);
        except
          // Handle as literal if invalid hex
          DecodedStr := DecodedStr + '#' + HexStr; 
        end;
      end else begin
          DecodedStr:= DecodedStr + '#'; // Handle '#' with no hex digits following
      end;


    end else
    begin
      DecodedStr := DecodedStr + InputStr[i];
      Inc(i);
    end;
  end;
  Result := DecodedStr;
end;
```

Changes:

* **Encoding:** The format specifier is changed to `%.2x`, which will use the minimum number of digits required but at least 2.
* **Decoding:** The hex digit parsing now dynamically reads any number of consecutive hex characters, ensuring full Unicode character support.  It also correctly handles cases where a '#' is not followed by any hex digits.

With this modification, the code is robust, supports Unicode, and correctly handles various edge cases.

--------------------
Q> What about the case when character '#' is present in the string to be encoded?

A> You're absolutely right.  If the original string contains a literal `#` character, the decoding function will misinterpret it as the start of an encoded sequence.  

Here's the corrected code that addresses this issue by escaping literal `#` characters during encoding:

```delphi
function EncodeNonPrintableChars(const InputStr: string): string;
var
  i: Integer;
  ch: Char;
  EncodedStr: string;
begin
  EncodedStr := '';
  for i := 1 to Length(InputStr) do
  begin
    ch := InputStr[i];
    if ch = '#' then
      EncodedStr := EncodedStr + '##' // Escape literal # characters
    else if (ch >= #32) and (ch <= #126) then
      EncodedStr := EncodedStr + ch
    else
      EncodedStr := EncodedStr + Format('#%.2x', [Ord(ch)]);
  end;
  Result := EncodedStr;
end;

function DecodeNonPrintableChars(const InputStr: string): string;
var
  i: Integer;
  DecodedStr: string;
  HexStr: string;
  Code: Integer;
begin
  DecodedStr := '';
  i := 1;
  while i <= Length(InputStr) do
  begin
    if (i <= Length(InputStr) -1) and (InputStr[i] = '#') and (InputStr[i+1] = '#') then
    begin
        // Double # means a literal #
        DecodedStr := DecodedStr + '#';
        inc(i,2); // Skip both # characters
    end
    else if InputStr[i] = '#' then
    begin
      Inc(i); // Skip '#'
      HexStr := '';
       while (i <= Length(InputStr)) and
            (InputStr[i] in ['0'..'9', 'A'..'F', 'a'..'f']) do
      begin
        HexStr := HexStr + InputStr[i];
        Inc(i);
      end;

      if HexStr <> '' then
      begin
        try
          Code := StrToInt('$' + HexStr);
          DecodedStr := DecodedStr + Char(Code);
        except
           DecodedStr := DecodedStr + '#' + HexStr; // Handle as literal if invalid
        end;
      end else begin
          DecodedStr := DecodedStr + '#'; // Handle '#' alone
      end;
    end else
    begin
      DecodedStr := DecodedStr + InputStr[i];
      Inc(i);
    end;
  end;
  Result := DecodedStr;
end;
```

Key Changes:

* **Encoding:**  Literal `#` characters are now escaped by doubling them (`##`).
* **Decoding:** The decoding function now checks specifically for the `##` sequence. If found, it's treated as a literal `#`. Otherwise, the decoding proceeds as before.



This improved version correctly handles literal `#` characters within the input string, making the encoding and decoding process reliable and reversible even in these cases.

